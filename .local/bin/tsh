#!/bin/bash

# configuration
SSH_OPTS=(-o "StrictHostKeyChecking=no")

# define files for log, pid, and ref counting
PIDFILE="/tmp/tsh.pid"
REFCOUNTFILE="/tmp/tsh.ref"
LOGFILE="/tmp/tsh.log"

# devtunnel
DEVTUNNEL=$(command -v devtunnel)

log() {
  local msg=$1
  echo "tsh: $msg" >&2
}

# manage refcount
refcount() {
  local opt=$1

  # initialize refcount
  if [[ ! -f "$REFCOUNTFILE" ]]; then
    echo 0 > "$REFCOUNTFILE"
  fi

  # read current refcount
  ref=$(<"$REFCOUNTFILE")

  case "$opt" in
    +)
      ((ref++))
      ;;

    -)
      if [[ $ref -gt 0 ]]; then
        ((ref--))
      fi
      ;;

    0)
      ref=0
      ;;

    *)
      echo $ref
      ;;
  esac

  # write refcount
  echo $ref > "$REFCOUNTFILE"
}

# checks if devtunnel is installed
is_devtunnel_installed() {
  if [[ ! -e $DEVTUNNEL ]]; then
    log "devtunnel is not installed."
    exit 1
  fi
}

# checks if an instance of devtunnel is already running (by pid)
is_devtunnel_running() {
  if [[ -e "$PIDFILE" ]]; then
    pid=$(cat "$PIDFILE")

    # no pid stored
    if [[ -z "$pid" ]]; then
      log "Detected empty PID file. Cleaning up."
      rm -f "$PIDFILE"
      return 1
    fi

    # check if pid belong to devtunnel
    if ps -p "$pid" | grep -q "devtunnel"; then
      echo "$pid"
      return 0
    else
      log "Detected stale PID file. Cleaning up."
      rm -f "$PIDFILE"
      return 1
    fi
  fi

  return 1
}

# start devtunnel and manage reference counting
start_devtunnel() {
  if ! is_devtunnel_running >/dev/null; then
    log "Starting a new devtunnel instance."
    devtunnel connect 2>&1 > "$LOGFILE" &
    echo $! > "$PIDFILE"
    refcount 0
  else
    log "Attaching to existing devtunnel instance."
  fi

  refcount +
}

# extract forwarded port number
get_devtunnel_local_port() {
  local timeout=30
  local host_port=$1

  while [[ $timeout -gt 0 ]]; do
    if grep -q "to host port $host_port" "$LOGFILE"; then
      local local_port=$(grep "SSH: Forwarding from" "$LOGFILE" | grep "to host port $host_port" | head -n 1 | sed -r "s/.*127.0.0.1:([0-9]+).*/\1/")
      log "Found port forward $local_port -> $host_port."
      echo "$local_port"
      return
    else
      sleep 1
      ((timeout--))
    fi
  done

  log "Timeout while waiting for devtunnel to provide the forwarded port."
  return 1
}

# cleanup on exit
cleanup() {
  # cleanup when refcount reaches 0
  refcount -
  if [[ $(refcount) -eq 0 ]]; then
    pid=$(is_devtunnel_running)
    if [[ $? -eq 0 ]]; then
      log "No more clients running, closing devtunnel instance."
      kill "$pid"
      rm -f "$PIDFILE"
    fi
    rm -f "$REFCOUNTFILE"
    rm -f "$LOGFILE"
  fi

  exit
}

# always cleanup on script termination
trap 'cleanup' EXIT


# command parsing
parse_command() {
  local port=$1; shift
  local opts=""
  local target=""
  local cmd=""

  # parse arguments
  while [[ "$#" -gt 0 ]]; do
    case $1 in
      -t|--target)
        target="$2"
        shift 2
        ;;

      proxy|shell|fwd|fs|cmd)
        cmd="$1"
        shift
        break
        ;;

      *)
        opts="$opts $1"
        shift
        ;;
    esac
  done

  # parse target
  local jump=""
  local dest=""
  if [[ -n $target ]]; then
    if [[ $target == *","* ]]; then
      # the last host in the comma separated target string is the target
      jump="localhost:$port,${target%,*}"
      dest="${target##*,}"
    else
      jump="localhost:$port"
      dest=$target
    fi
  fi

  # execute command
  case $cmd in
    shell)
      if [[ -n $jump ]]; then
        ssh "${SSH_OPTS[@]}" $opts -J $jump $dest $@
      else
        ssh "${SSH_OPTS[@]}" $opts -p $port localhost $@
      fi
      ;;

    proxy)
      if [[ -n $jump ]]; then
        sshuttle -e "ssh ${SSH_OPTS[*]} -J $jump" $opts -x localhost:$port -r $dest $@
      else
        sshuttle -e "ssh ${SSH_OPTS[*]}" $opts -x localhost:$port -r localhost:$port $@
      fi
      ;;
    
    fwd)
      if [[ -n $jump ]]; then
        ssh "${SSH_OPTS[@]}" $opts -J $jump -N -L $2:localhost:$1 $dest
      else
        ssh "${SSH_OPTS[@]}" $opts -p $port -N -L $2:localhost:$1 localhost
      fi
      ;;

    fs)
      if [[ -n $jump ]]; then
        sshfs $dest:$@ -o "ssh_command=ssh ${SSH_OPTS[*]} -J $jump" -f $opts
      else
        sshfs localhost:$@ -p $port -o "ssh_command=ssh ${SSH_OPTS[*]}" -f $opts
      fi
      ;;

    cmd)
      cmd=$(echo "$@" | host="localhost" port="$port" envsubst)
      $cmd
      ;;
  esac
}

usage() {
  echo "Usage: tsh [-t hosts] <command> [args...]"
  echo
  echo "Options:"
  echo "  -t, --target <hosts>      Specify target host. Multiple comma-separated hosts"
  echo "                            are used as jump hosts until the last one. If no target"
  echo "                            is specified, connection is made to tunnel host."
  echo
  echo "  *                         Any other options are passed down to the underlying"
  echo "                            command."
  echo
  echo "Commands:"
  echo "  shell                     Open an SSH session to target."
  echo "  proxy                     Forwards traffic over SSH (using sshuttle)."
  echo "  fwd <remote> <local>      Forwards port to target host."
  echo "  fs <remote> <local>       Mount remote filesystem."
  echo "  cmd '<cmd>'               Executes command, interpolating the host and port"
  echo '                            to the forwarded port as $host and $port.'
  echo
  echo "Any additional arguments are passed down to the underlying command."
  exit 1
}

main() {
  is_devtunnel_installed
  start_devtunnel
  port=$(get_devtunnel_local_port 22)

  if [[ -z "$port" ]]; then
    log "Exiting."
    exit 1
  fi

  parse_command "$port" "$@"
}

if [[ $# -lt 1 ]]; then
  usage
  exit 1
fi

main "$@"
